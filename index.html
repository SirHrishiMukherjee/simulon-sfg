<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>New Canada Warp Drive</title>
<style>
  :root{
    --bg: radial-gradient(1300px 900px at 50% 15%, #0e1220 0%, #0a0d17 55%, #06080f 100%);
    --ink:#e8f0ff; --muted:#a5b1cc; --edge:#6aa8ff; --glow:#79ffe1; --node:#ffffff;
    --ok:#47ff9d; --warn:#ffd35c; --bad:#ff6a6a;
    --shadow: 0 10px 30px rgba(0,0,0,.45), inset 0 0 40px rgba(255,255,255,.03);
  }
  *{box-sizing:border-box} html,body{height:100%;margin:0}
  body{
    display:flex;flex-direction:column;background: var(--bg), #0a0d17; color:var(--ink);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
  }
  header{padding:18px clamp(16px,4vw,36px); display:flex; justify-content:center}
  .title{
    font-weight:900;font-size:clamp(24px,4.2vw,46px);
    padding:.35rem .9rem;border-radius:16px;
    background:linear-gradient(180deg,rgba(255,255,255,.08),rgba(255,255,255,.02));
    border:1px solid rgba(255,255,255,.08); box-shadow:var(--shadow);
  }
  .wrap{display:grid;gap:16px; grid-template-columns: 1.25fr .85fr; padding: clamp(10px,3vw,28px)}
  @media (max-width: 1024px){ .wrap{grid-template-columns: 1fr} }

  .stage,.panel{
    background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
    border:1px solid rgba(255,255,255,.08); border-radius:20px; box-shadow: var(--shadow);
  }
  .stage{position:relative; min-height:560px; overflow:hidden}
  svg{width:100%; height:100%; display:block}

  .edge{ stroke: var(--edge); stroke-opacity:.38; stroke-width: 5; fill:none; filter:url(#edgeGlow) }
  .edge.active{ stroke-opacity:.85; stroke-width:8 }
  .edge.main{ stroke-width:10; stroke-opacity:.95 }

  .node{ fill: var(--node); stroke:#94c6ff; stroke-width:3; filter:url(#nodeGlow); transition: transform .12s ease }
  .node-wrap:hover .node{ transform: scale(1.06) }
  .hit{ fill: transparent; pointer-events: all }
  .label{
    font-weight:800; font-size: 14.5px; fill: var(--ink);
    paint-order: stroke; stroke: rgba(0,0,0,.55); stroke-width:3px; pointer-events:none;
  }
  .sublabel{ font-size:12px; fill:var(--muted); pointer-events:none }

  /* Particles */
  #particles{ pointer-events:none }
  .particle{
    fill: var(--glow);
    stroke: #cffff0;
    stroke-width: 0.6;
  }

  /* Warp effect */
  .warping{ animation: warpBlink .6s ease-in-out 1 }
  @keyframes warpBlink{
    0%{ opacity:1; transform: scale(1) }
    35%{ opacity:0; transform: scale(.25) }
    65%{ opacity:0; transform: scale(.25) }
    100%{ opacity:1; transform: scale(1) }
  }

  .panel{ padding:16px }
  .panel h2{ margin:0 0 10px; font-size:18px; letter-spacing:.4px }
  .group{ margin:12px 0 18px; padding:10px; border-radius:12px; border:1px dashed rgba(255,255,255,.12) }
  .group h3{ margin:0 0 8px; font-size:13px; color:var(--muted); text-transform:uppercase; letter-spacing:.6px }
  .row{ display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center; margin: 8px 0 }
  .row label{ font-size:13px }
  .row output{ font-variant-numeric: tabular-nums; color:#8bffcc }

  input[type="range"]{ width:100%; -webkit-appearance:none; background:transparent; height:28px }
  input[type="range"]::-webkit-slider-runnable-track{ height:8px; border-radius:8px; background: linear-gradient(90deg,#223,#2b3a5f); border:1px solid rgba(255,255,255,.12) }
  input[type="range"]::-webkit-slider-thumb{ -webkit-appearance:none; width:18px; height:18px; margin-top:-5px; border-radius:50%; background:#fff; border:2px solid #94c6ff; box-shadow: 0 0 0 6px rgba(121,255,225,.18) }
  input[type="range"]::-moz-range-track{ height:8px; border-radius:8px; background:#2b3a5f }
  input[type="range"]::-moz-range-thumb{ width:18px; height:18px; border-radius:50%; background:#fff; border:2px solid #94c6ff; box-shadow: 0 0 0 6px rgba(121,255,225,.18) }

  .controls{ display:flex; gap:10px; flex-wrap:wrap }
  .btn{
    background:#121a2a; color:var(--ink); border:1px solid rgba(255,255,255,.16);
    border-radius:12px; padding:10px 12px; cursor:pointer;
    transition: transform .08s ease, border-color .2s ease, box-shadow .2s ease;
  }
  .btn:hover{ transform: translateY(-1px); border-color: rgba(121,255,225,.6); box-shadow: 0 0 0 4px rgba(121,255,225,.1) inset }
  .mini{ font-size:12.5px; padding:6px 10px; opacity:.9 }

  .readouts{ display:grid; grid-template-columns: repeat(3,1fr); gap:10px; margin-top:8px }
  .meter{ background:#0e1422; border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:10px; text-align:center }
  .meter .v{ font-size:18px; font-weight:800 }
  .meter .ok{ color:var(--ok) } .meter .warn{ color:var(--warn) } .meter .bad{ color:var(--bad) }

  footer{ text-align:center; font-size:12.5px; color:var(--muted); padding:8px 12px 18px; user-select:none }
</style>
</head>
<body>
  <header><div class="title">New Canada Warp Drive</div></header>

  <div class="wrap">
    <div class="stage">
      <svg id="graph" viewBox="0 0 1000 680" role="img" aria-labelledby="svgTitle svgDesc">
        <title id="svgTitle">Warp Drive Interaction Graph</title>
        <desc id="svgDesc">INC, MEA, HO plus 12 SFGs in a toroidal ring; complete graph; continuous and burst particle flows; warp on repeated activation.</desc>

        <defs>
          <filter id="edgeGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="0" dy="0" stdDeviation="4" flood-color="#6aa8ff" flood-opacity=".55"/>
            <feDropShadow dx="0" dy="0" stdDeviation="10" flood-color="#79ffe1" flood-opacity=".28"/>
          </filter>
          <filter id="nodeGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="0" dy="0" stdDeviation="4" flood-color="#ffffff" flood-opacity=".9"/>
            <feDropShadow dx="0" dy="0" stdDeviation="10" flood-color="#79ffe1" flood-opacity:.4/>
          </filter>
          <linearGradient id="flux" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" stop-color="#6aa8ff"/><stop offset="100%" stop-color="#79ffe1"/>
          </linearGradient>
        </defs>

        <!-- edges layer -->
        <g id="edges"></g>
        <!-- particle layer -->
        <g id="particles"></g>
        <!-- nodes layer -->
        <g id="nodes"></g>
      </svg>
    </div>

    <div class="panel">
      <h2>Control Panel</h2>
      <div class="group">
        <h3>System Bias</h3>
        <div class="row">
          <label>Resonance Bias <output id="o_bias">0.50</output></label>
          <input id="bias" type="range" min="0" max="1" step="0.01" value="0.50"/>
        </div>
        <div class="row">
          <label>Flux Intensity <output id="o_flux">0.80</output></label>
          <input id="flux" type="range" min="0" max="1" step="0.01" value="0.80"/>
        </div>
      </div>

      <div class="controls">
        <button class="btn" id="toggle">Pause</button>
        <button class="btn mini" id="reset">Reset</button>
        <button class="btn mini" id="burst">Global Burst</button>
      </div>

      <div class="readouts">
        <div class="meter"><div>Coupling</div><div class="v" id="couplingVal">0.00</div></div>
        <div class="meter"><div>Coherence</div><div class="v" id="coherenceVal">0.00</div></div>
        <div class="meter"><div>Warp Readiness</div><div class="v" id="readinessVal">Idle</div></div>
      </div>
      <p style="margin-top:10px; color:var(--muted); font-size:12.5px">
        Tip: Click any node to emit a burst to all others. After several activations, the node <em>warps</em>.
      </p>
    </div>
  </div>

  <footer>Property of Copyright Hrishi Mukherjee Horizons 2025</footer>

<script>
(() => {
  const svg = document.getElementById('graph');
  const nodeLayer = document.getElementById('nodes');
  const edgeLayer = document.getElementById('edges');
  const particleLayer = document.getElementById('particles');

  // ----- Node definitions -----
  const CORE = [
    { id:'INC', label:'Inertial Null Core', sub:'Nullness • Stability', r:28, x:170, y:340 },
    { id:'MEA', label:'Membrane Emitter Array', sub:'Gain • Density', r:26, x:430, y:130 },
    { id:'HO',  label:'Harmonic Oscillator', sub:'Frequency • Q', r:26, x:770, y:340 },
  ];
  const CENTER = { x:500, y:340, R:150 };
  const SFGS = Array.from({length:12}, (_,i) => {
    const a = (i/12)*Math.PI*2;
    return { id:`SFG${i+1}`, label:'SFG', sub:`Simulonic Field Gen #${i+1}`, r:18,
             x: CENTER.x + CENTER.R*Math.cos(a),
             y: CENTER.y + CENTER.R*Math.sin(a) };
  });
  const ALL = [...CORE, ...SFGS];

  const NS = 'http://www.w3.org/2000/svg';
  function makeNode(n){
    const g = document.createElementNS(NS,'g');
    g.classList.add('node-wrap'); g.dataset.id=n.id;
    g.setAttribute('transform', `translate(${n.x},${n.y})`);
    const hit = document.createElementNS(NS,'circle'); hit.setAttribute('class','hit'); hit.setAttribute('r', n.r+20);
    const c   = document.createElementNS(NS,'circle'); c.setAttribute('class','node'); c.setAttribute('r', n.r);
    const t1  = document.createElementNS(NS,'text');  t1.setAttribute('class','label'); t1.setAttribute('text-anchor','middle'); t1.setAttribute('dy', -(n.r+20)); t1.textContent = n.label;
    const t2  = document.createElementNS(NS,'text');  t2.setAttribute('class','sublabel'); t2.setAttribute('text-anchor','middle'); t2.setAttribute('dy', n.r+22); t2.textContent = n.sub;
    g.appendChild(hit); g.appendChild(c); g.appendChild(t1); g.appendChild(t2);
    nodeLayer.appendChild(g);
    n.g=g; n.hit=hit; n.circ=c;
  }
  ALL.forEach(makeNode);

  // Drag core nodes
  CORE.forEach(n=>enableDrag(n));
  function enableDrag(n){
    let dragging=false, ox=0, oy=0;
    n.hit.addEventListener('pointerdown', e=>{
      dragging=true; e.target.setPointerCapture(e.pointerId);
      ox = e.clientX - n.x; oy = e.clientY - n.y;
    });
    window.addEventListener('pointermove', e=>{
      if(!dragging) return;
      n.x = Math.max(40, Math.min(960, e.clientX - ox));
      n.y = Math.max(60, Math.min(640, e.clientY - oy));
      n.g.setAttribute('transform', `translate(${n.x},${n.y})`);
      updateAllEdges();
    });
    window.addEventListener('pointerup', ()=> dragging=false);
  }

  // ----- Edges: complete graph -----
  const edges = []; // {a,b,path,main}
  function bez(a,b,bulge=24){
    const dx=b.x-a.x, dy=b.y-a.y, mx=(a.x+b.x)/2, my=(a.y+b.y)/2;
    const len = Math.hypot(dx,dy)||1, ux=-dy/len, uy=dx/len;
    const cx = mx + ux*bulge, cy = my + uy*bulge;
    return `M ${a.x} ${a.y} Q ${cx} ${cy} ${b.x} ${b.y}`;
  }
  function addEdge(a,b, main=false){
    const p = document.createElementNS(NS,'path');
    p.setAttribute('class','edge' + (main?' main':''));
    p.setAttribute('stroke','url(#flux)');
    p.setAttribute('d', bez(a,b, main?40:24));
    edgeLayer.appendChild(p);
    edges.push({a,b,path:p,main});
  }
  // Emphasized core triangle
  addEdge(ALL.find(n=>n.id==='INC'), ALL.find(n=>n.id==='MEA'), true);
  addEdge(ALL.find(n=>n.id==='MEA'), ALL.find(n=>n.id==='HO'),  true);
  addEdge(ALL.find(n=>n.id==='HO'),  ALL.find(n=>n.id==='INC'), true);
  // Complete graph
  for(let i=0;i<ALL.length;i++){
    for(let j=i+1;j<ALL.length;j++){
      const ia=ALL[i].id, jb=ALL[j].id;
      const isMain = (ia==='INC'&&jb==='MEA')||(ia==='MEA'&&jb==='HO')||(ia==='HO'&&jb==='INC');
      if(!isMain) addEdge(ALL[i], ALL[j], false);
    }
  }
  function updateAllEdges(){
    edges.forEach(e=> e.path.setAttribute('d', bez(e.a,e.b, e.main?40:24)));
  }

  // ----- Particles (continuous + bursts) -----
  const MAX_PARTICLES = 900;
  const particles = []; // {el, path, t, speed}

  function spawnParticleOnPath(path, intensity=1){
    // cap & recycle
    if(particles.length >= MAX_PARTICLES){
      const old = particles.shift();
      if(old && old.el && old.el.parentNode) old.el.parentNode.removeChild(old.el);
    }
    const el = document.createElementNS(NS,'circle');
    el.setAttribute('class','particle');
    const baseR = 2.8;
    el.setAttribute('r', (baseR + Math.random()*1.4*intensity).toFixed(2));
    particleLayer.appendChild(el);

    const p = { el, path, t: Math.random()*0.2, speed: 0.0022 + Math.random()*0.003*intensity };
    particles.push(p);

    // place immediately so it's visible before first tick
    try {
      const len = path.getTotalLength();
      const pt  = path.getPointAtLength(p.t * len);
      el.setAttribute('cx', pt.x); el.setAttribute('cy', pt.y);
      el.setAttribute('opacity', 0.55 + 0.4*(1-p.t));
    } catch(e){}
  }

  function connectedEdgesOf(node){
    return edges.filter(e=> e.a===node || e.b===node);
  }

  function burstFromNode(node, magnitude=1){
    const connected = connectedEdgesOf(node);
    connected.forEach(e=> e.path.classList.add('active'));
    setTimeout(()=> connected.forEach(e=> e.path.classList.remove('active')), 900);

    const count = Math.floor(8 + 16*magnitude);
    for(const e of connected){
      for(let i=0;i<count;i++) spawnParticleOnPath(e.path, 0.9 + 0.6*magnitude);
    }
  }

  // Continuous emission (“streams”) based on Flux slider
  function continuousEmit(){
    const flux = +document.getElementById('flux').value; // 0..1
    // choose a few random edges each frame to emit on; scale with flux
    const emitEdges = Math.floor(2 + flux * 14);
    for(let i=0;i<emitEdges;i++){
      const e = edges[(Math.random()*edges.length)|0];
      const intensity = 0.6 + 0.9*flux;
      spawnParticleOnPath(e.path, intensity);
    }
  }

  // ----- Warp mechanic -----
  const warpCounter = Object.fromEntries(ALL.map(n=>[n.id,0]));
  const WARP_THRESHOLD = 5;

  function doWarp(n){
    n.g.classList.add('warping');
    setTimeout(()=> n.g.classList.remove('warping'), 620);
    if(n.id.startsWith('SFG')){
      const j=6; n.x += (Math.random()*2-1)*j; n.y += (Math.random()*2-1)*j;
      n.g.setAttribute('transform', `translate(${n.x},${n.y})`);
      updateAllEdges();
    }
  }

  // Clicks: burst + warp counter
  ALL.forEach(n=>{
    n.hit.addEventListener('click', ()=>{
      burstFromNode(n, 1.2);
      warpCounter[n.id] += 1;
      if(warpCounter[n.id] >= WARP_THRESHOLD){ warpCounter[n.id]=0; doWarp(n); }
    });
  });

  // ----- Meters -----
  const bias = document.getElementById('bias');
  const flux = document.getElementById('flux');
  const o_bias = document.getElementById('o_bias');
  const o_flux = document.getElementById('o_flux');
  [bias,flux].forEach(s=> s.addEventListener('input', ()=>{
    if(s===bias) o_bias.textContent = (+bias.value).toFixed(2);
    if(s===flux) o_flux.textContent = (+flux.value).toFixed(2);
  }));

  const couplingVal  = document.getElementById('couplingVal');
  const coherenceVal = document.getElementById('coherenceVal');
  const readinessVal = document.getElementById('readinessVal');

  function computeRingSymmetry(){
    const targetR = CENTER.R; let acc = 0;
    for(const s of SFGS){
      const dr = Math.hypot(s.x-CENTER.x, s.y-CENTER.y) - targetR;
      acc += Math.max(0, 1 - Math.min(1, Math.abs(dr)/20));
    }
    return acc / SFGS.length;
  }
  function computeState(){
    const particleFactor = Math.min(1, particles.length / MAX_PARTICLES);
    const ringSymmetry   = computeRingSymmetry();
    const coupling = Math.max(0, Math.min(1, 0.30*particleFactor + 0.25*ringSymmetry + 0.45*(+flux.value)));
    const coherence= Math.max(0, Math.min(1, 0.45*ringSymmetry + 0.20*particleFactor + 0.35*(1 - Math.abs(+bias.value-0.5)*2)));
    let readiness='Idle', cls='warn';
    if(coupling>0.75 && coherence>0.75){ readiness='Warp-Ready'; cls='ok' }
    else if(coupling>0.5 && coherence>0.5){ readiness='Aligning'; cls='warn' }
    else { readiness='Unstable'; cls='bad' }
    return {coupling, coherence, readiness, cls};
  }

  // ----- Animation loop (safe removal + continuous emit) -----
  let running = true, last=performance.now()/1000;
  function tick(ms){
    const now=ms/1000, dt=Math.min(0.05, now-last); last=now;

    // continuous streams
    continuousEmit();

    // advance particles (iterate backwards so splices are safe)
    const speedScale = 0.35 + 1.6*(+flux.value);
    for(let i=particles.length-1; i>=0; i--){
      const p = particles[i];
      p.t += p.speed * speedScale * (1 + 0.25*Math.sin(now*2 + i)); // a little shimmer
      if(p.t >= 1){
        // remove
        if(p.el && p.el.parentNode) p.el.parentNode.removeChild(p.el);
        particles.splice(i,1);
        continue;
      }
      try{
        const len = p.path.getTotalLength();
        const pt  = p.path.getPointAtLength(p.t * len);
        p.el.setAttribute('cx', pt.x);
        p.el.setAttribute('cy', pt.y);
        p.el.setAttribute('opacity', 0.6 + 0.35*(1 - p.t));
      }catch(e){}
    }

    // meters
    const S = computeState();
    couplingVal.textContent  = S.coupling.toFixed(2);
    coherenceVal.textContent = S.coherence.toFixed(2);
    readinessVal.textContent = S.readiness;
    readinessVal.className = 'v ' + (S.cls==='ok'?'ok':S.cls==='warn'?'warn':'bad');

    if(running) requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // ----- Controls -----
  document.getElementById('toggle').addEventListener('click', (e)=>{
    running = !running;
    e.target.textContent = running ? 'Pause' : 'Resume';
    if(running){ last = performance.now()/1000; requestAnimationFrame(tick); }
  });
  document.getElementById('reset').addEventListener('click', ()=>{
    bias.value=0.50; flux.value=0.80; o_bias.textContent='0.50'; o_flux.textContent='0.80';
    // restore ring geometry
    SFGS.forEach((s,i)=>{
      const a=(i/12)*Math.PI*2; s.x=CENTER.x + CENTER.R*Math.cos(a); s.y=CENTER.y + CENTER.R*Math.sin(a);
      s.g.setAttribute('transform', `translate(${s.x},${s.y})`);
    });
    for(const k in warpCounter) warpCounter[k]=0;
    updateAllEdges();
  });
  document.getElementById('burst').addEventListener('click', ()=>{
    ALL.forEach(n=> burstFromNode(n, 1.4));
  });

  // Kickstart: light initial flows so it feels alive immediately
  for(let i=0;i<200;i++){
    const e = edges[(Math.random()*edges.length)|0];
    spawnParticleOnPath(e.path, 0.9);
  }

})();
</script>
</body>
</html>
