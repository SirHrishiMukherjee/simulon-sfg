<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>New Canada Warp Drive</title>
<style>
  :root{
    --bg: radial-gradient(1300px 900px at 50% 15%, #0e1220 0%, #0a0d17 55%, #06080f 100%);
    --ink:#e8f0ff; --muted:#a5b1cc; --edge:#6aa8ff; --glow:#79ffe1; --node:#ffffff;
    --ok:#47ff9d; --warn:#ffd35c; --bad:#ff6a6a;
    --shadow: 0 10px 30px rgba(0,0,0,.45), inset 0 0 40px rgba(255,255,255,.03);
  }
  *{box-sizing:border-box} html,body{height:100%;margin:0}
  body{
    display:flex;flex-direction:column;background: var(--bg), #0a0d17; color:var(--ink);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
  }
  header{padding:18px clamp(16px,4vw,36px); display:flex; justify-content:center}
  .title{
    font-weight:900;font-size:clamp(24px,4.2vw,46px);
    padding:.35rem .9rem;border-radius:16px;
    background:linear-gradient(180deg,rgba(255,255,255,.08),rgba(255,255,255,.02));
    border:1px solid rgba(255,255,255,.08); box-shadow:var(--shadow);
  }
  .wrap{display:grid;gap:16px; grid-template-columns: 1.25fr .85fr; padding: clamp(10px,3vw,28px)}
  @media (max-width: 1024px){ .wrap{grid-template-columns: 1fr} }

  .stage,.panel{
    background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
    border:1px solid rgba(255,255,255,.08); border-radius:20px; box-shadow: var(--shadow);
  }
  .stage{position:relative; min-height:560px; overflow:hidden}
  svg{width:100%; height:100%; display:block}

  .edge{ stroke: var(--edge); stroke-opacity:.38; stroke-width: 5; fill:none; filter:url(#edgeGlow) }
  .edge.active{ stroke-opacity:.85; stroke-width:8 }
  .edge.main{ stroke-width:10; stroke-opacity:.95 }

  .node{ fill: var(--node); stroke:#94c6ff; stroke-width:3; filter:url(#nodeGlow); transition: transform .12s ease }
  .node-wrap:hover .node{ transform: scale(1.06) }
  .hit{ fill: transparent; pointer-events: all }
  .label{
    font-weight:800; font-size: 14.5px; fill: var(--ink);
    paint-order: stroke; stroke: rgba(0,0,0,.55); stroke-width:3px; pointer-events:none;
  }
  .sublabel{ font-size:12px; fill:var(--muted); pointer-events:none }

  /* Particles */
  #particles{ pointer-events:none }
  .particle{
    fill: var(--glow);
    stroke: #cffff0;
    stroke-width: 0.6;
  }

  /* Warp effect */
  .warping{ animation: warpBlink .6s ease-in-out 1 }
  @keyframes warpBlink{
    0%{ opacity:1; transform: scale(1) }
    35%{ opacity:0; transform: scale(.25) }
    65%{ opacity:0; transform: scale(.25) }
    100%{ opacity:1; transform: scale(1) }
  }

  /* Intent arrow */
  .intent-arrow{ filter:url(#edgeGlow) }
  .intent-stem{ stroke:url(#flux); stroke-width:8; stroke-opacity:.85; fill:none }
  .intent-head{ fill:url(#flux); opacity:.9 }
  .intent-core{ fill: none; stroke:#79ffe1; stroke-dasharray:5 6; stroke-opacity:.5 }

  .panel{ padding:16px }
  .panel h2{ margin:0 0 10px; font-size:18px; letter-spacing:.4px }
  .group{ margin:12px 0 18px; padding:10px; border-radius:12px; border:1px dashed rgba(255,255,255,.12) }
  .group h3{ margin:0 0 8px; font-size:13px; color:var(--muted); text-transform:uppercase; letter-spacing:.6px }
  .row{ display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center; margin: 8px 0 }
  .row label{ font-size:13px }
  .row output{ font-variant-numeric: tabular-nums; color:#8bffcc }

  input[type="range"]{ width:100%; -webkit-appearance:none; background:transparent; height:28px }
  input[type="range"]::-webkit-slider-runnable-track{ height:8px; border-radius:8px; background: linear-gradient(90deg,#223,#2b3a5f); border:1px solid rgba(255,255,255,.12) }
  input[type="range"]::-webkit-slider-thumb{ -webkit-appearance:none; width:18px; height:18px; margin-top:-5px; border-radius:50%; background:#fff; border:2px solid #94c6ff; box-shadow: 0 0 0 6px rgba(121,255,225,.18) }
  input[type="range"]::-moz-range-track{ height:8px; border-radius:8px; background:#2b3a5f }
  input[type="range"]::-moz-range-thumb{ width:18px; height:18px; border-radius:50%; background:#fff; border:2px solid #94c6ff; box-shadow: 0 0 0 6px rgba(121,255,225,.18) }

  select, .btn{
    background:#121a2a; color:var(--ink); border:1px solid rgba(255,255,255,.16);
    border-radius:12px; padding:10px 12px; cursor:pointer;
    transition: transform .08s ease, border-color .2s ease, box-shadow .2s ease;
  }
  .btn:hover, select:hover{ transform: translateY(-1px); border-color: rgba(121,255,225,.6); box-shadow: 0 0 0 4px rgba(121,255,225,.1) inset }
  .mini{ font-size:12.5px; padding:6px 10px; opacity:.9 }

  .controls{ display:flex; gap:10px; flex-wrap:wrap }

  .readouts{ display:grid; grid-template-columns: repeat(3,1fr); gap:10px; margin-top:8px }
  .meter{ background:#0e1422; border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:10px; text-align:center }
  .meter .v{ font-size:18px; font-weight:800 }
  .meter .ok{ color:var(--ok) } .meter .warn{ color:var(--warn) } .meter .bad{ color:var(--bad) }

  footer{ text-align:center; font-size:12.5px; color:var(--muted); padding:8px 12px 18px; user-select:none }
  .hint{ color:var(--muted); font-size:12.5px }
</style>
</head>
<body>
  <header><div class="title">New Canada Warp Drive</div></header>

  <div class="wrap">
    <div class="stage">
      <svg id="graph" viewBox="0 0 1000 680" role="img" aria-labelledby="svgTitle svgDesc">
        <title id="svgTitle">Warp Drive Interaction Graph</title>
        <desc id="svgDesc">INC, MEA, HO plus 12 SFGs in a toroidal ring; complete graph; continuous and burst particle flows; warp on repeated activation; CII Intent Vector bias.</desc>

        <defs>
          <filter id="edgeGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="0" dy="0" stdDeviation="4" flood-color="#6aa8ff" flood-opacity=".55"/>
            <feDropShadow dx="0" dy="0" stdDeviation="10" flood-color="#79ffe1" flood-opacity=".28"/>
          </filter>
          <filter id="nodeGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="0" dy="0" stdDeviation="4" flood-color="#ffffff" flood-opacity=".9"/>
            <feDropShadow dx="0" dy="0" stdDeviation="10" flood-color="#79ffe1" flood-opacity:.4/>
          </filter>
          <linearGradient id="flux" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" stop-color="#6aa8ff"/><stop offset="100%" stop-color="#79ffe1"/>
          </linearGradient>
          <marker id="arrowHead" viewBox="0 0 16 16" refX="8" refY="8" markerWidth="12" markerHeight="12" orient="auto-start-reverse">
            <path d="M0,0 L16,8 L0,16 L4,8 Z" class="intent-head"/>
          </marker>
        </defs>

        <!-- edges layer -->
        <g id="edges"></g>
        <!-- particle layer -->
        <g id="particles"></g>
        <!-- nodes layer -->
        <g id="nodes"></g>
        <!-- intent vector layer -->
        <g id="intentLayer" class="intent-arrow"></g>
      </svg>
    </div>

    <div class="panel">
      <h2>Control Panel</h2>

      <div class="group">
        <h3>System Bias</h3>
        <div class="row">
          <label>Resonance Bias <output id="o_bias">0.50</output></label>
          <input id="bias" type="range" min="0" max="1" step="0.01" value="0.50"/>
        </div>
        <div class="row">
          <label>Flux Intensity <output id="o_flux">0.80</output></label>
          <input id="flux" type="range" min="0" max="1" step="0.01" value="0.80"/>
        </div>
      </div>

      <div class="group">
        <h3>CII Control Core — Intent Vector</h3>
        <div class="row">
          <label>Bearing (°) <output id="o_bearing">0</output></label>
          <input id="bearing" type="range" min="0" max="360" step="1" value="0"/>
        </div>
        <div class="row">
          <label>Magnitude <output id="o_mag">0.70</output></label>
          <input id="mag" type="range" min="0" max="1" step="0.01" value="0.70"/>
        </div>
        <div class="row">
          <label>Gain <output id="o_gain">0.60</output></label>
          <input id="gain" type="range" min="0" max="2" step="0.01" value="0.60"/>
        </div>
        <div class="row">
          <label>Focus</label>
          <select id="focus">
            <option value="all">All Links</option>
            <option value="core">Core Triangle</option>
            <option value="sfg">SFG Ring</option>
            <option value="target">Toward Target Node</option>
          </select>
        </div>
        <div class="row">
          <label>Target Node</label>
          <select id="targetNode">
            <option value="INC">INC</option>
            <option value="MEA">MEA</option>
            <option value="HO">HO</option>
            <option value="SFG1">SFG1</option><option value="SFG2">SFG2</option>
            <option value="SFG3">SFG3</option><option value="SFG4">SFG4</option>
            <option value="SFG5">SFG5</option><option value="SFG6">SFG6</option>
            <option value="SFG7">SFG7</option><option value="SFG8">SFG8</option>
            <option value="SFG9">SFG9</option><option value="SFG10">SFG10</option>
            <option value="SFG11">SFG11</option><option value="SFG12">SFG12</option>
          </select>
        </div>
        <div class="controls" style="margin-top:8px">
          <button class="btn mini" id="pulse">Intent Pulse</button>
          <label style="display:flex;align-items:center;gap:8px">
            <input type="checkbox" id="autoSteer" /> Auto-steer to Coherence
          </label>
        </div>
        <div class="hint" style="margin-top:6px">
          The Intent Vector biases energy routing along its bearing; focus narrows which links are prioritized. Auto-steer continuously rotates intent toward higher coherence.
        </div>
      </div>

      <div class="controls">
        <button class="btn" id="toggle">Pause</button>
        <button class="btn mini" id="reset">Reset</button>
        <button class="btn mini" id="burst">Global Burst</button>
      </div>

      <div class="readouts">
        <div class="meter"><div>Coupling</div><div class="v" id="couplingVal">0.00</div></div>
        <div class="meter"><div>Coherence</div><div class="v" id="coherenceVal">0.00</div></div>
        <div class="meter"><div>Warp Readiness</div><div class="v" id="readinessVal">Idle</div></div>
      </div>
      <p style="margin-top:10px" class="hint">
        Tip: Click any node to emit a burst to all others. After several activations, the node <em>warps</em>.
      </p>
    </div>
  </div>

  <footer>Property of Copyright Hrishi Mukherjee Horizons 2025</footer>

<script>
(() => {
  const svg = document.getElementById('graph');
  const nodeLayer = document.getElementById('nodes');
  const edgeLayer = document.getElementById('edges');
  const particleLayer = document.getElementById('particles');
  const intentLayer = document.getElementById('intentLayer');

  // ----- Node definitions -----
  const CORE = [
    { id:'INC', label:'Inertial Null Core', sub:'Nullness • Stability', r:28, x:170, y:340 },
    { id:'MEA', label:'Membrane Emitter Array', sub:'Gain • Density', r:26, x:430, y:130 },
    { id:'HO',  label:'Harmonic Oscillator', sub:'Frequency • Q', r:26, x:770, y:340 },
  ];
  const CENTER = { x:500, y:340, R:150 };
  const SFGS = Array.from({length:12}, (_,i) => {
    const a = (i/12)*Math.PI*2;
    return { id:`SFG${i+1}`, label:'SFG', sub:`Simulonic Field Gen #${i+1}`, r:18,
             x: CENTER.x + CENTER.R*Math.cos(a),
             y: CENTER.y + CENTER.R*Math.sin(a) };
  });
  const ALL = [...CORE, ...SFGS];

  const NS = 'http://www.w3.org/2000/svg';
  function makeNode(n){
    const g = document.createElementNS(NS,'g');
    g.classList.add('node-wrap'); g.dataset.id=n.id;
    g.setAttribute('transform', `translate(${n.x},${n.y})`);
    const hit = document.createElementNS(NS,'circle'); hit.setAttribute('class','hit'); hit.setAttribute('r', n.r+20);
    const c   = document.createElementNS(NS,'circle'); c.setAttribute('class','node'); c.setAttribute('r', n.r);
    const t1  = document.createElementNS(NS,'text');  t1.setAttribute('class','label'); t1.setAttribute('text-anchor','middle'); t1.setAttribute('dy', -(n.r+20)); t1.textContent = n.label;
    const t2  = document.createElementNS(NS,'text');  t2.setAttribute('class','sublabel'); t2.setAttribute('text-anchor','middle'); t2.setAttribute('dy', n.r+22); t2.textContent = n.sub;
    g.appendChild(hit); g.appendChild(c); g.appendChild(t1); g.appendChild(t2);
    nodeLayer.appendChild(g);
    n.g=g; n.hit=hit; n.circ=c;
  }
  ALL.forEach(makeNode);

  // Drag core nodes
  CORE.forEach(n=>enableDrag(n));
  function enableDrag(n){
    let dragging=false, ox=0, oy=0;
    n.hit.addEventListener('pointerdown', e=>{
      dragging=true; e.target.setPointerCapture(e.pointerId);
      ox = e.clientX - n.x; oy = e.clientY - n.y;
    });
    window.addEventListener('pointermove', e=>{
      if(!dragging) return;
      n.x = Math.max(40, Math.min(960, e.clientX - ox));
      n.y = Math.max(60, Math.min(640, e.clientY - oy));
      n.g.setAttribute('transform', `translate(${n.x},${n.y})`);
      updateAllEdges();
      updateIntentGraphics(); // keep overlay visually consistent
    });
    window.addEventListener('pointerup', ()=> dragging=false);
  }

  // ----- Edges: complete graph -----
  const edges = []; // {a,b,path,main}
  function bez(a,b,bulge=24){
    const dx=b.x-a.x, dy=b.y-a.y, mx=(a.x+b.x)/2, my=(a.y+b.y)/2;
    const len = Math.hypot(dx,dy)||1, ux=-dy/len, uy=dx/len;
    const cx = mx + ux*bulge, cy = my + uy*bulge;
    return `M ${a.x} ${a.y} Q ${cx} ${cy} ${b.x} ${b.y}`;
  }
  function addEdge(a,b, main=false){
    const p = document.createElementNS(NS,'path');
    p.setAttribute('class','edge' + (main?' main':'')); p.setAttribute('stroke','url(#flux)');
    p.setAttribute('d', bez(a,b, main?40:24));
    edgeLayer.appendChild(p);
    edges.push({a,b,path:p,main});
  }
  // Emphasized core triangle
  addEdge(ALL.find(n=>n.id==='INC'), ALL.find(n=>n.id==='MEA'), true);
  addEdge(ALL.find(n=>n.id==='MEA'), ALL.find(n=>n.id==='HO'),  true);
  addEdge(ALL.find(n=>n.id==='HO'),  ALL.find(n=>n.id==='INC'), true);
  // Complete graph
  for(let i=0;i<ALL.length;i++){
    for(let j=i+1;j<ALL.length;j++){
      const ia=ALL[i].id, jb=ALL[j].id;
      const isMain = (ia==='INC'&&jb==='MEA')||(ia==='MEA'&&jb==='HO')||(ia==='HO'&&jb==='INC');
      if(!isMain) addEdge(ALL[i], ALL[j], false);
    }
  }
  function updateAllEdges(){
    edges.forEach(e=> e.path.setAttribute('d', bez(e.a,e.b, e.main?40:24)));
  }

  // ----- Particles (continuous + bursts) -----
  const MAX_PARTICLES = 900;
  const particles = []; // {el, path, t, speed}

  function spawnParticleOnPath(path, intensity=1){
    if(particles.length >= MAX_PARTICLES){
      const old = particles.shift();
      if(old && old.el && old.el.parentNode) old.el.parentNode.removeChild(old.el);
    }
    const el = document.createElementNS(NS,'circle');
    el.setAttribute('class','particle');
    const baseR = 2.8;
    el.setAttribute('r', (baseR + Math.random()*1.4*intensity).toFixed(2));
    particleLayer.appendChild(el);

    const p = { el, path, t: Math.random()*0.2, speed: 0.0022 + Math.random()*0.003*intensity };
    particles.push(p);

    try {
      const len = path.getTotalLength();
      const pt  = path.getPointAtLength(p.t * len);
      el.setAttribute('cx', pt.x); el.setAttribute('cy', pt.y);
      el.setAttribute('opacity', 0.55 + 0.4*(1-p.t));
    } catch(e){}
  }

  function connectedEdgesOf(node){
    return edges.filter(e=> e.a===node || e.b===node);
  }

  function burstFromNode(node, magnitude=1){
    const connected = connectedEdgesOf(node);
    connected.forEach(e=> e.path.classList.add('active'));
    setTimeout(()=> connected.forEach(e=> e.path.classList.remove('active')), 900);

    const count = Math.floor(8 + 16*magnitude);
    for(const e of connected){
      for(let i=0;i<count;i++) spawnParticleOnPath(e.path, 0.9 + 0.6*magnitude);
    }
  }

  // ----- CII Intent Vector -----
  const bearing = document.getElementById('bearing');
  const mag = document.getElementById('mag');
  const gain = document.getElementById('gain');
  const focusSel = document.getElementById('focus');
  const targetSel = document.getElementById('targetNode');
  const autoSteer = document.getElementById('autoSteer');

  const o_bearing = document.getElementById('o_bearing');
  const o_mag = document.getElementById('o_mag');
  const o_gain = document.getElementById('o_gain');

  [bearing, mag, gain].forEach(el => el.addEventListener('input', ()=>{
    o_bearing.textContent = bearing.value;
    o_mag.textContent = (+mag.value).toFixed(2);
    o_gain.textContent = (+gain.value).toFixed(2);
    updateIntentGraphics();
  }));
  [focusSel, targetSel].forEach(el => el.addEventListener('change', updateIntentGraphics));

  function deg2rad(d){ return d*Math.PI/180; }
  function intentVec(){
    const th = deg2rad(+bearing.value);
    const m = +mag.value;
    return { x: Math.cos(th)*m, y: Math.sin(th)*m, th, m };
  }

  // Draw arrow + dashed intent core circle
  const intentStem = document.createElementNS(NS,'path');
  intentStem.setAttribute('class','intent-stem'); intentStem.setAttribute('marker-end','url(#arrowHead)');
  const intentCore = document.createElementNS(NS,'circle');
  intentCore.setAttribute('class','intent-core'); intentCore.setAttribute('cx', CENTER.x); intentCore.setAttribute('cy', CENTER.y); intentCore.setAttribute('r', CENTER.R+18);
  const intentLabel = document.createElementNS(NS,'text');
  intentLabel.setAttribute('x', CENTER.x); intentLabel.setAttribute('y', CENTER.y- (CENTER.R+36));
  intentLabel.setAttribute('text-anchor','middle'); intentLabel.setAttribute('class','label'); intentLabel.textContent='CII Intent';
  intentLayer.appendChild(intentCore); intentLayer.appendChild(intentStem); intentLayer.appendChild(intentLabel);

  function updateIntentGraphics(){
    const R = CENTER.R + 130;
    const V = intentVec();
    const x2 = CENTER.x + Math.cos(V.th)*R;
    const y2 = CENTER.y + Math.sin(V.th)*R;
    // shorten based on magnitude (0..1)
    const scale = 0.35 + 0.65*V.m;
    const xEnd = CENTER.x + (x2-CENTER.x)*scale;
    const yEnd = CENTER.y + (y2-CENTER.y)*scale;
    const ctrl = 0.18; // subtle curve
    const cx = CENTER.x + (xEnd-CENTER.x)* (1-ctrl) - (yEnd-CENTER.y)*0.08;
    const cy = CENTER.y + (yEnd-CENTER.y)* (1-ctrl) + (xEnd-CENTER.x)*0.08;
    intentStem.setAttribute('d', `M ${CENTER.x} ${CENTER.y} Q ${cx} ${cy} ${xEnd} ${yEnd}`);
  }
  updateIntentGraphics();

  function nodeById(id){ return ALL.find(n=>n.id===id); }

  // Weighted edge selection by intent alignment & focus
  function pickIntentWeightedEdge(){
    const V = intentVec();
    const g = +gain.value;
    const focus = focusSel.value;
    const target = nodeById(targetSel.value);

    // precompute weights
    let total = 0;
    const weights = new Array(edges.length).fill(0);
    for(let i=0;i<edges.length;i++){
      const e = edges[i];
      // focus filtering
      if(focus==='core' && !(isCore(e.a) && isCore(e.b))) { weights[i]=0; continue; }
      if(focus==='sfg' && !(isSFG(e.a) && isSFG(e.b))) { weights[i]=0; continue; }
      if(focus==='target' && !(e.a===target || e.b===target)) { weights[i]=0; continue; }

      // direction vector from center along edge midpoint
      const mx=(e.a.x+e.b.x)/2, my=(e.a.y+e.b.y)/2;
      const ex = mx - CENTER.x, ey = my - CENTER.y;
      const elen = Math.hypot(ex,ey)||1;
      const dx = ex/elen, dy = ey/elen;

      // alignment in [-1,1] -> [0,1]
      const align = Math.max(0, (dx*V.x + dy*V.y)); // clamp negatives to 0 so we don't starve the opposite side
      const base = 1; // uniform base
      const w = base * (1 + V.m * g * align);
      weights[i]=w; total += w;
    }
    if(total<=0) return edges[(Math.random()*edges.length)|0];

    // roulette wheel selection
    let r = Math.random()*total;
    for(let i=0;i<weights.length;i++){
      r -= weights[i];
      if(r<=0) return edges[i];
    }
    return edges[edges.length-1];
  }

  function isCore(n){ return n.id==='INC'||n.id==='MEA'||n.id==='HO'; }
  function isSFG(n){ return n.id.startsWith('SFG'); }

  // Continuous emission with intent bias
  function continuousEmit(){
    const flux = +document.getElementById('flux').value; // 0..1
    const emitEdges = Math.floor(2 + flux * 14);
    for(let i=0;i<emitEdges;i++){
      const e = pickIntentWeightedEdge();
      const intensity = 0.6 + 0.9*flux;
      spawnParticleOnPath(e.path, intensity);
    }
  }

  // Intent Pulse = burst from target along intent-biased neighbors
  document.getElementById('pulse').addEventListener('click', ()=>{
    const tgt = nodeById(targetSel.value) || CORE[0];
    burstFromNode(tgt, 1.5);
  });

  // ----- Warp mechanic -----
  const warpCounter = Object.fromEntries(ALL.map(n=>[n.id,0]));
  const WARP_THRESHOLD = 5;

  function doWarp(n){
    n.g.classList.add('warping');
    setTimeout(()=> n.g.classList.remove('warping'), 620);
    if(n.id.startsWith('SFG')){
      const j=6; n.x += (Math.random()*2-1)*j; n.y += (Math.random()*2-1)*j;
      n.g.setAttribute('transform', `translate(${n.x},${n.y})`);
      updateAllEdges();
      updateIntentGraphics();
    }
  }

  // Clicks: burst + warp counter + retarget (quick target toggle with Shift)
  ALL.forEach(n=>{
    n.hit.addEventListener('click', (evt)=>{
      burstFromNode(n, 1.2);
      warpCounter[n.id] += 1;
      if(warpCounter[n.id] >= WARP_THRESHOLD){ warpCounter[n.id]=0; doWarp(n); }
      if(evt.shiftKey){ targetSel.value = n.id; updateIntentGraphics(); }
    });
  });

  // ----- Meters -----
  const bias = document.getElementById('bias');
  const flux = document.getElementById('flux');
  const o_bias = document.getElementById('o_bias');
  const o_flux = document.getElementById('o_flux');
  [bias,flux].forEach(s=> s.addEventListener('input', ()=>{
    if(s===bias) o_bias.textContent = (+bias.value).toFixed(2);
    if(s===flux) o_flux.textContent = (+flux.value).toFixed(2);
  }));

  const couplingVal  = document.getElementById('couplingVal');
  const coherenceVal = document.getElementById('coherenceVal');
  const readinessVal = document.getElementById('readinessVal');

  function computeRingSymmetry(){
    const targetR = CENTER.R; let acc = 0;
    for(const s of SFGS){
      const dr = Math.hypot(s.x-CENTER.x, s.y-CENTER.y) - targetR;
      acc += Math.max(0, 1 - Math.min(1, Math.abs(dr)/20));
    }
    return acc / SFGS.length;
  }

  // Intent alignment (readout influence)
  function computeIntentAlignment(){
    const V = intentVec();
    // average direction of ring midpoints
    let ax=0, ay=0;
    for(const s of SFGS){
      const vx = s.x - CENTER.x, vy = s.y - CENTER.y;
      const L = Math.hypot(vx,vy)||1;
      ax += vx/L; ay += vy/L;
    }
    const L = Math.hypot(ax,ay)||1; ax/=L; ay/=L;
    const dot = Math.max(0, ax*V.x + ay*V.y); // [0,1]
    return dot;
  }

  function computeState(){
    const particleFactor = Math.min(1, particles.length / MAX_PARTICLES);
    const ringSymmetry   = computeRingSymmetry();
    const intentAlign    = computeIntentAlignment();
    const coupling = Math.max(0, Math.min(1,
      0.26*particleFactor + 0.24*ringSymmetry + 0.35*(+flux.value) + 0.15*intentAlign*(+gain.value)/2
    ));
    const coherence= Math.max(0, Math.min(1,
      0.42*ringSymmetry + 0.18*particleFactor + 0.30*(1 - Math.abs(+bias.value-0.5)*2) + 0.10*intentAlign
    ));
    let readiness='Idle', cls='warn';
    if(coupling>0.75 && coherence>0.75){ readiness='Warp-Ready'; cls='ok' }
    else if(coupling>0.5 && coherence>0.5){ readiness='Aligning'; cls='warn' }
    else { readiness='Unstable'; cls='bad' }
    return {coupling, coherence, readiness, cls};
  }

  // ----- Auto-steer (CII guidance) -----
  function autoSteerUpdate(dt){
    if(!autoSteer.checked) return;
    // Heuristic: find SFG with largest radial error; steer vector from that SFG toward center
    let worst=null, worstErr=-1;
    const R = CENTER.R;
    for(const s of SFGS){
      const dr = Math.abs(Math.hypot(s.x-CENTER.x, s.y-CENTER.y)-R);
      if(dr>worstErr){ worstErr=dr; worst=s; }
    }
    if(!worst) return;
    const ang = Math.atan2(CENTER.y - worst.y, CENTER.x - worst.x); // towards center from worst SFG
    // blend bearing slowly toward desired angle
    let current = deg2rad(+bearing.value);
    // shortest angular difference
    let diff = ((ang - current + Math.PI*3) % (Math.PI*2)) - Math.PI;
    const rate = 0.9; // rad/s max turn
    const step = Math.max(-rate*dt, Math.min(rate*dt, diff));
    current += step;
    let deg = current*180/Math.PI;
    if(deg<0) deg+=360;
    bearing.value = (deg % 360).toFixed(0);
    o_bearing.textContent = bearing.value;
    updateIntentGraphics();
  }

  // ----- Animation loop -----
  let running = true, last=performance.now()/1000;
  function tick(ms){
    const now=ms/1000, dt=Math.min(0.05, now-last); last=now;

    continuousEmit();

    // advance particles
    const speedScale = 0.35 + 1.6*(+flux.value);
    for(let i=particles.length-1; i>=0; i--){
      const p = particles[i];
      p.t += p.speed * speedScale * (1 + 0.25*Math.sin(now*2 + i));
      if(p.t >= 1){
        if(p.el && p.el.parentNode) p.el.parentNode.removeChild(p.el);
        particles.splice(i,1); continue;
      }
      try{
        const len = p.path.getTotalLength();
        const pt  = p.path.getPointAtLength(p.t * len);
        p.el.setAttribute('cx', pt.x);
        p.el.setAttribute('cy', pt.y);
        p.el.setAttribute('opacity', 0.6 + 0.35*(1 - p.t));
      }catch(e){}
    }

    autoSteerUpdate(dt);

    // meters
    const S = computeState();
    couplingVal.textContent  = S.coupling.toFixed(2);
    coherenceVal.textContent = S.coherence.toFixed(2);
    readinessVal.textContent = S.readiness;
    readinessVal.className = 'v ' + (S.cls==='ok'?'ok':S.cls==='warn'?'warn':'bad');

    if(running) requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // ----- Controls -----
  document.getElementById('toggle').addEventListener('click', (e)=>{
    running = !running;
    e.target.textContent = running ? 'Pause' : 'Resume';
    if(running){ last = performance.now()/1000; requestAnimationFrame(tick); }
  });

  document.getElementById('reset').addEventListener('click', ()=>{
    // sliders
    bias.value=0.50; flux.value=0.80; o_bias.textContent='0.50'; o_flux.textContent='0.80';
    bearing.value=0; o_bearing.textContent='0';
    mag.value=0.70; o_mag.textContent='0.70';
    gain.value=0.60; o_gain.textContent='0.60';
    focusSel.value='all'; targetSel.value='INC'; autoSteer.checked=false;

    // ring geometry
    SFGS.forEach((s,i)=>{
      const a=(i/12)*Math.PI*2; s.x=CENTER.x + CENTER.R*Math.cos(a); s.y=CENTER.y + CENTER.R*Math.sin(a);
      s.g.setAttribute('transform', `translate(${s.x},${s.y})`);
    });
    for(const k in warpCounter) warpCounter[k]=0;
    updateAllEdges();
    updateIntentGraphics();
  });

  document.getElementById('burst').addEventListener('click', ()=>{
    ALL.forEach(n=> burstFromNode(n, 1.4));
  });

  // Kickstart: light initial flows so it feels alive immediately
  for(let i=0;i<200;i++){
    const e = edges[(Math.random()*edges.length)|0];
    spawnParticleOnPath(e.path, 0.9);
  }
})();
</script>
</body>
</html>
